--- mutt/ChangeLog
+++ mutt/ChangeLog
@@ -1,3 +1,16 @@
+2005-08-04 01:15:52  brendan  (brendan)
+
+	* compose.c: Don't unlink non-mutt files that would have been
+	unlinked on send if the message is cancelled.
+
+2005-08-02 18:15:33  Brendan Cully  <brendan@kublai.com>  (brendan)
+
+	* compose.c, mutt.h: In compose menu, detach should be able to
+	unlink files generated by mutt, but not files that existed before.
+
+	* compose.c: Don't unlink attachments that you've decided not
+	to send. (closes #1328)
+
 2005-04-10 09:37:51  Johan Svedberg  <johan@svedberg.pp.se>  (roessler)
 
 	* po/sv.po: update
--- mutt/mutt.h	1 Aug 2005 07:35:04 -0000	3.45
+++ mutt/mutt.h	2 Aug 2005 14:39:56 -0000	3.46
@@ -855,6 +855,7 @@ typedef struct attachptr
   char *tree;
   int level;
   int num;
+  unsigned int unowned : 1;   /* don't unlink on detach */
 } ATTACHPTR;
 
 typedef struct
--- mutt/compose.c	3 Feb 2005 17:01:42 -0000	3.22
+++ mutt/compose.c	4 Aug 2005 01:15:52 -0000	3.25
@@ -686,6 +686,7 @@ int mutt_compose_menu (HEADER *msg,   /*
 	  {
 	    char *att = files[i];
 	    idx[idxlen] = (ATTACHPTR *) safe_calloc (1, sizeof (ATTACHPTR));
+            idx[idxlen]->unowned = 1;
 	    idx[idxlen]->content = mutt_make_file_attach (att);
 	    if (idx[idxlen]->content != NULL)
 	      update_idx (menu, idx, idxlen++);
@@ -814,6 +815,8 @@ int mutt_compose_menu (HEADER *msg,   /*
 
       case OP_DELETE:
 	CHECK_COUNT;
+        if (idx[menu->current]->unowned)
+          idx[menu->current]->content->unlink = 0;
 	if (delete_attachment (menu, &idxlen, menu->current) == -1)
 	  break;
 	mutt_update_tree (idx, idxlen);
@@ -1143,6 +1146,8 @@ int mutt_compose_menu (HEADER *msg,   /*
 	    /* avoid freeing other attachments */
 	    idx[idxlen]->content->next = NULL;
 	    idx[idxlen]->content->parts = NULL;
+            if (idx[idxlen]->unowned)
+              idx[idxlen]->content->unlink = 0;
 	    mutt_free_body (&idx[idxlen]->content);
 	    FREE (&idx[idxlen]->tree);
 	    FREE (&idx[idxlen]);
